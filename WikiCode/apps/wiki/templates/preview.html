<!DOCTYPE html><html><title>Основы Java</title><xmp theme="journal" style="display:none;"># Введение

Курс "Информационные системы и технологии" будет посвящен построению распределенных информационных систем. В качестве языка программирования при этом в основном будет использоваться Java, так как с этим языком связано большое количество технологий, ориентированных на построение больших информационных систем.

План примерно такой:

В первом семестре планируется изучить:

1. **Основы Java**
2. **Многопоточность** и конкурентное выполнение задач, как одну из наиболее важных аспектов работы распределенных приложений.
3. **Сетевое программирование.** TCP/UDP сжатие, шифрование, блокирующий и неблокирующий ввод-вывод.
4. **Построение веб-приложений**, как один из наиболее популярных способов построения распределенных приложений.

Во втором семестре:

5. Трехзвенные и многозвенные архитектуры приложений.
6. Базы данных и ORM
7. Сервера приложений
8. Брокеры сообщений
9. Веб-сервисы и интеграция информационных систем. 

<По-хорошему, всё, что написано до сих пор, - вступительное слово. Желательно вынести эту информацию из блока материалов.>

## Основы Java

Первая лекция содержит в себе обзор языка Java, его отличий от С++, историю развития, современное состояние и основные отличия в синтаксисе. <Зачем это в обучающих материалах? Лучше убрать.>

**Java** - строгий статически типизированный объектно-ориентированный язык программирования с С-подобным синтаксисом. В отличие от С++ является именно **объектно-ориентированным**, а не мультипарадигменным языком программирования. В Java нет поддержки процедурного программирования и нет поддержки прямого доступа к памяти, поэтому в каком-то смысле Java можно рассматривать как урезанную и высушенную версию С++. Но, как вы понимаете, отбрасывание ненужных частей упрощает сам язык и разработку на нём, именно этим принципом во многом и руководствовались разработчики Java. Поэтому Java, в отличии от С++, достаточно простой язык, позволяющий писать программы даже людям, не имеющим специальной подготовки.

Нельзя сказать, что Java создавалась как замена С++, но тем не менее, присутствовала необходимость решить некоторые проблемы С++, так как С++ набирал очень большую популярность, но с другой стороны у других языков (Smalltalk, Oberon, Eiffel) было много полезных черт и очень хотелось совместить привычный многим Си-подобный синтаксис с этими чертами. Так появилась Java.

Основные проблемы С++, которые предполагала решить Java:

* модульность;
* ошибки работы с памятью;
* разделение ресурсов при параллельной обработке;
* кроссплатформенность.

Конечно сейчас всё это выглядит не так, как 20 лет назад, но многие из этих проблем до сих пор требуют лучших решений. <Что Вы пытались этим сказать? Эту мысль можно и убрать, т.к следующий абзац продолжает тему основных проблем С++.>

Для исправления этих недочётов было решено использовать виртуальную машину в качестве промежуточного звена между языком программирования и операционной системой, что позволяло упростить реализацию модульности, метапрограммирования, управления памятью и, разумеется, кроссплатформенности.

Виртуальная машина позволяет:

* запускать написанные на Java приложения на любой архитектуре;
* контролировать доступ и управление памятью полностью автоматически;
* легко подключать модули, скомпилированные на других архитектурах, в том числе на других языках.

Последнее, кстати, в конце концов привело к тому, что виртуальная машина Java во многом стала самостоятельным продуктом, используемым при программировании на других языках (Scala, Clojure, JRuby, Groovy) и позволяющим при этом без каких-либо затрат использовать Java-библиотеки, которых существует великое множество.

Собственно, во многом именно по причине простоты подключения библиотек и изначальных гарантий совместимости приложений вокруг Java возникло очень большое открытое сообщество, что по большому счету и является главным преимуществом Java-платформы.

К недостаткам Java можно отнести:

* высокий расход памяти виртуальной машиной;
* долгий запуск приложения;
* некоторую многословность языка;
* трудности с использованием *нативного* API (GUI, процессы, сети).

На данный момент Java - один из самых популярных языков программирования (во многих рейтингах занимает первую строчку).

Пожалуй, наиболее популярна Java в прикладном серверном ПО (back-end), создании корпоративных информационных систем и распределенных приложений. Также используется для мобильной разработки на Android, имеет реализации для запуска на встраиваемых устройствах и даже микроконтроллерах, и, разумеется, на Java можно писать настольные приложения.

Таким образом, Java - язык для создания широкого профиля прикладного ПО.

## Средства разработки

Для разработки приложений на Java требуется JDK (Java Development Kit), который можно свободно скачать с сайта [Oracle](http://www.oracle.com/technetwork/java/javase/downloads/index.html). В Linux-дистрибутивах обычно в репозиториях можно найти свободную реализацию JDK - OpenJDK. Некоторые компании, например IBM, разрабатывают свои версии JDK. Есть  альтернативные реализации, например Avian. В целом, все спецификации открыты, поэтому при желании можно самостоятельно реализовать JDK.

Самой популярной является Oracle JDK, пожалуй, её и рекомендуется использовать. На её основе можно создавать коммерческие приложения и распространять их без каких-либо лицензионных отчислений, если вы, конечно, не изменяете сам JDK.

JDK включает в себя:

* Java Runtime Enviroment (JRE) - собственно, саму виртуальную машину Java, которая позволит запускать java-приложения. JRE можно поставить и отдельно без JDK, если вам нужно только запускать, но не разрабатывать Java-приложения;

* утилиты для разработки, самой главной утилитой является `javac` - компилятор, преобразующий исходный код на языке java в байткод-файлы с расширением `.class`.

Пример `HelloWorld.java`:

```java
public class HelloWorld {

  public static void main(String[] args){
  
  	System.out.println("Hello world");
  }

}
```

Если мы решим не просто запустить проект в IDE, а захотим посмотреть, что происходит на уровне компилятора, то увидим следующее.

Сама программа является текстовым файлом с расширением '.java'. Командой `javac HelloWorld.java` мы его компилируем и получаем файл `HelloWorld.class`. (По аналогии с С++: у нас были исходники, из которых мы получали '.o'-файлы.) Файл с расширением '.class' содержит виртуальный (промежуточный) машинный код (так называемый байт-код), который исполняется не процессором, а виртуальной машиной.

Дальше в С++ шла линковка. В Java происходит по-другому: командой `java -cp . HelloWorld` вызывается виртуальная машина, где параметр `-cp` (т.н. Class Path) указывает на папку, в которой следует искать класс, а `HelloWorld` - имя класса, который нужно запустить. В каком-то смысле команда `java` выступает одновременно и линковщиком, и средством запуска программы. То есть, с одной стороны мы добавили дополнительное звено - виртуальную машину, но с другой стороны для программиста стало даже проще. Правда, теперь запускать этот линковщик придется и пользователям.

Если файлов с расширением '.class' много, то их можно объединить в архив командой `jar` (получаются просто собранные вместе '.class'-файлы).

Пишутся программы на Java следующим образом: пишется класс, внутри которого находится функция main(). У любого приложения в Java может быть много функций main, если в нем имеется несколько классов. Т.к. все используемые файлы с расширением '.class' находятся в одной папке и какой из них будет использован определяется параметром '-cp', отличий между исполняемыми файлами и файлами библиотек нет. 

Собственно и всё. Нет никаких статически подключаемых библиотек, всё подключается динамически, поскольку линковка происходит только в RunTime. Если вам нужны какие-то сторонние библиотеки, то вы добавляете их в Class Path. 

Разумеется, вручную всё это делать приходится довольно редко, так как для разработки существует большое количество IDE, в частности, мы будем использовать [Netbeans](https://netbeans.org/downloads/) (для начала можно ограничиться SE версией, но для разработки веб-приложений понадобится EE версия). Netbeans вместе с JDK можно скачать с сайта [Oracle](http://www.oracle.com/technetwork/java/javase/downloads/index.html) одним комплектом.

## Синтаксис Java

Как вы уже заметили, Java - это объектно-ориентированный язык, и даже самая простая программа требует описания класса. В остальном всё очень похоже на С++. 

Любая функция — это метод, переменные либо вложены в функцию, либо являются полями класса; таким образом, глобальных переменных в понимании С++ нет.

В Java любая переменная является объектом, кроме  8 примитивных типов данных, которые не являются объектами. Они были определены с самой первой версии и никогда не менялись. Это четыре целочисленных типа: `byte`, `short`, `int`, `long`, также к ним относят символьный `char`(причем он двухбайтовый для поддержки юникода), два дробных типа `float` и `double` и, наконец, булевский тип `boolean`. **Беззнаковых типов нет**. Создавать свои примитивные типы нельзя. Все остальные типы (в том числе те, которые мы можем создать) - объектные или **ссылочные** (англ. reference ). Ключевого слова const нет, но если возникает необходимость создать константную переменную, то пишется слово final.

Все переменные примитивных типов объявляются уже привычным нам образом:

```java
int a;
float r = 3f; 
final float t = 8;
t = 7;            //нельзя!
```
Примитивные типы ведут себя также, как и в С++: переменная внутри функции создаётся на стеке, по её завершении переменная "умирает". 

Ссылочные типы данных на самом деле по сути гораздо ближе к указателям С++, чем к ссылкам.
Даже по объявлению:

```java
String s = new String("sdfgf");  //создается объект String и нам возвращается что-то типа указателя на него
String s = null; //указатель на null
```
Если же мы напишем просто:

```java
String str;
```
то это еще не будет созданием строки, появится лишь ссылка на стеке.

Мы можем перенаправить ссылку, а также скопировать её:

```java
s = new String("vvfvddf"); //перенаправили ссылку
String rrr = s; //скопировали ссылку на объект. Значение **не** копируется, оно по-прежнему одно.
```
К слову, строки в Java неизменяемые.

Соответственно, при передаче в функцию передаются ссылки, а не значения (8 примитивных типов передаются по значению). 

Можно условно считать, что все примитивные объекты **создаются в стеке**, а все **ссылочные - в куче**. 

В Java нет ни **конструкторов копирования** (и тем более конструкторов перемещения), ни перегрузки **операции присваивания** (перегрузки операций вообще нет), так же, как и нет операции **delete** и **деструкторов**. После создания переменной вам не нужно беспокоиться об её удалении, так как встроенный сборщик мусора освободит объект за вас (причем проблем, свойственных `std::shared_ptr` в С++ нет, так как используются более интеллектуальные механизмы, чем подсчет количества ссылок), поэтому утечек памяти (по крайней мере связанных с неосвобождением) нет, зато появляется другие утечки из-за наличия не удаленных ссылок. 

Прямого доступа к памяти нет, поэтому ошибки работы с памятью просто невозможны.

## Модульность и пакеты

В Java в отличие от `C++` нет разделения на заголовочные и файлы реализации. Подключить мы можем только классы с помощью оператора 'import`. В качестве пространств имён выступают пакеты (package).

Итак, простая программа:

```java
package javaapplication4;

import java.io.Console;
import java.util.Scanner;

public class JavaApplication4
{
    public static void main(String[] args)
    {  
        int[] arr = new int[10]; //массивы все динамические
        
        // знают свою длину
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i + 1;            
        }
        
        // цикл while тоже есть
        int i = 0;        
        while(i < arr.length){
            System.out.println(arr[i]); 
            i++;            
        } 
        
        System.out.println("Hello world" + 3);        
        
        // класс для чтения с консоли (на самом деле чтение основных типов из текстовых данных
        final Scanner scanner = new Scanner(System.in);
        final int a = scanner.nextInt();
        final int b = scanner.nextInt();
        
        System.out.println(a+b);
        
        Console console = System.console();
        if (console == null) {
            System.out.println("Unable to fetch console");
            return;
        }
        final String line = console.readLine();
        System.out.println("Hello "+line);         
    }   
}

class InternalClass {   
    
    int a = 0;    
    
    class InnerClass{        
        InnerClass(){            
            InternalClass.this.a++;            
        }
    } 
}

```
<Пример, безусловно, интересный, но лучше для демонстрации работы оператора import привести простейший пример. А этот код указать в конце для резюмирования пройденного (чтобы до этого кода можно было объяснить массивы, циклы)>

В каждом файле может быть объявлено сколько угодно классов, но быть публичным (ключевое слово public) может только один, и называться он должен так же, как и сам файл. Непубличные классы (равно как и поля и методы, у которых не указана область видимости) видимы только внутри данного пакета. Импортировать мы можем только публичный класс. 

Для каждого метода и поля класса следует указывать область видимости:`public`, `protected` или `private`, ничем не отличающиеся от С++. Если вы не укажете область видимости, то она будет дефолтная, что означает видимость внутри данного пакета.

## Каноны и соглашения именования в Java

В Java существуют достаточно большое количество соглашений, которым строго следуют. В отличие от С++, где в STL одно соглашение именований, в библиотеке Qt - другое, в Java есть один общий стандарт. 

То, как мы ранее называли наши пакеты, на самом деле является не совсем каноничным. Принято именовать свой пакет согласно обратному доменному имени организации, в которой создается проект: например, `package ru.stankin.uits.lec1;`. Это удобно, так как по названию становится понятным, кто разрабатывал данный package. Вообще, подобное именование не является обязательным, ведь, если у вас нет своего сайта, это не значит, что вы не можете программировать на Java. К тому же нет никакой гарантии, что, связавшись с указанной в названии пакета организацией, вы сможете найти автора.

Ниже приведено ещё несколько соглашений, которые полезно знать:

* имена пакетов пишутся с маленькой буквы;
* классы пишутся с большой буквы, каждое новое - также с большой буквы `class JavaApplication`;
* переменные начинаются с маленькой буквы, каждое новое слово - с большой `int myImportantValue`.

## Некоторые возможности IDE

Поскольку Java - простой и логичный язык, то IDE очень помогает при написании программ. Например, выделение метода:

```java
String str = new String("sss");
```
Выделение строки -> "лампочка" -> introduce method (ввести метод) -> ввести имя метода (в данном случае erer)

или

Выделение строки -> правая кнопка мыши -> средство реорганизации кода -> ввести -> метод -> ввести имя метода

```java
String str = erer();

...

private static String erer() {
     String str = new String ("ssss");
     return str;
}

```


Можно создать сгенерировать конструктор:

```java

public class NewClass {
     
     int a;
     
     public void foo() {
     }
}
```

source -> insert code -> constructor

```java

public class NewClass {

     int a;

     public void foo() {
     }

     public NewClass (int a) {
        this.a = a;
     }
}
```

Также есть возможность сгенерировать геттеры и сеттеры:

source -> insert code -> getter/setter

```java

public class NewClass {

     int a;

     public void foo() {
     }

     public NewClass (int a) {
        this.a = a;
     }

     public int getA() {
        return a;
     }

     public void setA (int a) {
        this.a = a;
     }
}
```
## Краткие сведения о простых конструкциях

Массивы:

```java

int[] a = new int[10];  //динамический, статических массивов нет; удалять не нужно, т.к. есть сборщик мусора
int[][] a = new int[10][40]; // двумерный массив

```

Циклы такие же, как в С++:

```java
int[] a = new int[10];

for (int i = 0; i < a.length; i++) {    //массивы достаточно сообразительны, чтобы хранить свою длину
     a[i] = 9;
}


//цикл for_each
int[] b = new int [10];
for (int a1 : a) {

}
```

Чтение с консоли.

Никакого cin в Java нет. Есть класс System, в котором есть стандартные потоки: in, out, err. Поток out является бинарно-текстовым, в него можно писать при помощи функции println. Входной поток (System.in) - бинарный, читать из него можно только байты, поэтому, чтобы читать с консоли какие-либо данные, следует использовать обертки, например, класс Scanner.

```java

Scanner s = new Scanner (System.in);  //читает из System.in
int nextInt = s.nextInt();            //считывание целого числа

```

Класс (встроенные класс) Person
сгенерировать методы, сгенерировать конструктор. Документирование
Показать доступ.
Вынести в отдельный класс.
Пакеты. (и правила их именования)
Статические методы.
Массивы.
Циклы

## Литература

Меня тут спрашивали про литературу, пожалуй, могу посоветовать следующее:

*  Брюс Эккель. "Философия Java"
*  Кей Хорстман, Гари Корнел. "Java. Библиотека профессионала в двух томах". Про Java до 8-ой версии.
*  Cay S. Horstmann. "Java SE 8 for the Really Impatient" - 2014. Про Java 8. Переведена некачественно, так что лучше читать в оригинале.
*  Шилдт. Про Java 8 у него есть книга, насколько она переведена на русский не знаю, но на английском читать можно.

<Желательно рекомендуемую литературу вынести во вступительное слово, там она будет уместнее.>

## JavaDocs

Название JavaDocs говорит само за себя - это документация к Java. Средства документирования встроены в язык и являются расширениями комментариев, например, запись вида

```java
/**
 * This sentence holds the main description for this documentation comment.
 * @see java.lang.Object
 */
```

может являться описанием к любому полю. По сути это просто комментарий, в начале которого пишутся две звездочки `/**` и со `*` начинается каждая новая строчка.

Внутри можно использовать специальные теги, например: 

`@param` для указания параметра, 

`@return` для описания возвращаемого значения.

Впрочем, практически все такие теги IDE сгенерирует для вас сама. Можно отметить отдельно теги

`@deprecated` для указания устаревших методов 

и тег `{@link package.class#member label}` для указания ссылок внутри документации.

В документации можно использовать html-теги и при помощи утилиты `javadoc` можно сгенерировать документацию в формате html.

При обращении к методу, имеющему документирующий комментарий, IDE отображает существующую документацию. Таким образом, в процессе написания кода описание метода всегда под рукой.

Документация по всему JDK написана в javadoc и может быть легко подключена к проекту.


## Наследование

Наследование в Java достаточно урезано - можно наследоваться только публично и только от одного класса (множественное наследование реализаций невозможно). Производится при помощи ключевого слова `extends`.

В Java есть возможность создавать так называемые **интерфейсы** - классы без реализаций методов и без состояний (По сути являются абстрактными классами, у которых все функции абстрактные.).

```java

public interface NewInterface {

     void foo();

}
```
Один класс может реализовывать несколько интерфейсов, для этого используется специальное ключевое слово `implements`.

> В Java 8 интерфейсы могут иметь так называемую `default` реализацию методов, но состояний по-прежнему иметь не могут, поэтому это не множественное наследование. Если в результирующем классе есть разные default-реализации одного и того же метода, то будет ошибка компиляции.

```java

public interface NewInterface {

     default void foo() {
     //какая-то реализация
     }
}

```

<Нужен пример с конфликтом при одинаковых именах функций у "родителей".>

Создавать экземпляры интерфейсов, как и объекты абстрактных классов, нельзя, но можно объявить переменную этого интерфейса. В Java это создание анонимных классов. 

```java
        Runnable runnable = new Runnable() {      //создали переменную интерфейса Runnable
                                                  //сразу унаследовались от него
            @Override
            public void run() {                   //и сделали реализацию здесь же
                System.out.println("asdfasdf");
            }
        };
```

В Java 8 в случае, если в интерфейсе нужно реализовывать только один метод, можно записать короче:

```java
Runnable runnable = () -> System.out.println("asdfasdf");
```
Это и есть реализация лямбда-выражений в Java.

Что касается виртуальных функций, то ключевое слово `virtual` в Java отсутствует, так как все методы всегда являются виртуальными (кроме статических). Переопределение метода можно запретить при помощи ключевого слова `final` (в С++11 оно тоже появилось). Также можно обозначить класс словом `final`, тогда наследоваться от него будет нельзя. На заметку: писать `final` является правилом хорошего тона.
</xmp><script src="http://strapdownjs.com/v/0.2/strapdown.js"></script></html>